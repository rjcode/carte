h1. Carte

Carte is ORM for Clojure, without the O. It's more of an MRM or IMRM but we don't need to get into that right now.

The basic idea is that you tell carte about the structure of the database that you are dealing with. When a query is executed, carte will figure out a query plan, execute it and then compile the results into a nested data structure. Carte also provides functions to make it easier to manipulate these data structures. Finally, carte can save entire data structures, or even lists of data structures, in one step, automatically figuring out which records need to be saved, updated and deleted.

The goal is to provide seamless interaction between the world of relational databases and Clojure's world of persistent data structures.

The project is currently being developed against MySQL but the plan is to make it database independent. I plan to implement support for MySQL, Derby and ProsgreSQL. Once this is done, it should be easy for others to add support for other back ends.

Every disclaimer goes here...

Note: The sample data has been changed but the documentation has not yet been updated. If you follow along with the documentation below, your results with vary.

h2. Setting up MySQL and Cloning Carte

If you would like to experiment with carte then the best way would be to follow these instructions which assume that you have MySQL installed and that you are using "Leiningen":http://github.com/technomancy/leiningen. 

First you will need to create the test database.

<pre>
<code>
$ mysql -u root -p 
$ CREATE DATABASE carte_test_db;
$ GRANT ALL PRIVILEGES ON carte_test_db.* TO carte_db_user@localhost IDENTIFIED BY '123456789';
$ exit
</code>
</pre>

Next, clone this repository and run the tests.

<pre>
<code>
$ git clone git://github.com/brentonashworth/carte.git
$ cd carte
$ lein deps
$ lein test
</code>
</pre>

This will run a bunch of unit tests and will create some tables in the test database which we created in the previous step.

h2. Configuring Carte

Two things are required in order for carte to work, a database configuration and a data model definition. Below is the configuration for connecting to the test database that was created above. 

<pre>
<code>
(def db {:connection {:classname "com.mysql.jdbc.Driver"
                      :subprotocol "mysql"
                      :subname "//localhost/carte_test_db"
                      :user "carte_db_user"
                      :password "123456789"}})
</code>
</pre>

A data model is created using the <code>model</code> macro. Below we create a simple data model for the test database. This example only shows creating many-to-many associations but there is also currently support for one-to-many. In the future there will be support for belongs-to and one-to-one.

<pre>
<code>
(def data-model
     (model
      (album [:id :title]
             (many-to-many :artist))
      (artist [:id :name]
              (many-to-many :album => :album_artist))))
</code>
</pre>

The above example shows the most concise way to describe this model. Below is an example of being explicit.

<pre>
<code>
(def data-model
     (model
      (album [:id :title]
             (many-to-many artists :artist
              => :album_artist :album_id :artist_id))
      (artist [:id :name]
              (many-to-many albums :album 
               => :album_artist :artist_id :album_id))))
</code>
</pre>

Finally, create some helper functions which close over the database configuration and data model.

<pre>
<code>
(def ! (partial save-or-update db data-model))
(def $ (partial query db data-model))
(def $1 (partial query-1 db data-model))
</code>
</pre>

h2. Example Queries

If you would like to follow along with these examples then you may start up a REPL and execute the following expressions. The <code>carte.test-core</code> namespace will set up our database configuration, create a data model and create the helper functions described above. <code>default-test-data</code> will load sample data that we may experiment with. 

<pre>
<code>
user> (use 'carte.core)
user> (use 'carte.test-core)
user> (default-test-data) 
</code>
</pre>

We are now ready to run some queries.

<pre>
<code>
user> ($ :album)
({:id 4 :title "Magic Potion"} 
 {:id 5 :title "Thickfreakness"} 
 {:id 6 :title "Let's Dance"})

user> ($ :artist)
({:id 3 :name "The Black Keys"} 
 {:id 4 :name "David Bowie"})

user> (meta (first *1))
{:carte.core/type :artist 
 :carte.core/original {:id 3 :name "The Black Keys"}}

user> ($ :album {:title "Mag*"})
({:id 4 :title "Magic Potion"})

user> ($ :album {:title "Mag*" :id 4} {:title "Let's Dance"})
({:id 4 :title "Magic Potion"} 
 {:id 6 :title "Let's Dance"})

user> ($ :album {:where ["title &lt;= ?" "Magic Potion"]})
({:id 4 :title "Magic Potion"} 
 {:id 6 :title "Let's Dance"})

user> ($ :album :with :artists)
({:id 4 
  :title "Magic Potion" 
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 5 
  :title "Thickfreakness" 
  :artists []} 
 {:id 6 
  :title "Let's Dance"
  :artists []})

user> ($ :artist :with :albums)
({:id 3 
  :name "The Black Keys" 
  :albums [{:id 4 :title "Magic Potion"}]} 
 {:id 4 
  :name "David Bowie" 
  :albums []})
</code>
</pre>

Note that metadata is used to store the name of the table that each record comes from as well as the original value of each record. This is used to determine if a record is dirty and should be updated.

Let's take a look at the queries that were used to retrieve this data.

<pre>
<code>
user> (binding [*debug* true] 
        ($ :album {:title "Mag*"}))
["SELECT album.id as album_id, album.title as album_title FROM album WHERE album.title like ?" "Mag%"]
({:id 4 :title "Magic Potion"})

user> (binding [*debug* true] 
        ($ :album {:title "Mag*" :id 4} {:title "Let's Dance"}))
["SELECT album.id as album_id, album.title as album_title 
   FROM album 
   WHERE (album.title like ? AND album.id = ?) OR (album.title = ?)" "Mag%" 4 "Let's Dance"]
({:id 4 :title "Magic Potion"} 
 {:id 6 :title "Let's Dance"})

user> (binding [*debug* true] 
        ($ :album :with :artists))
["SELECT album.id as album_id, album.title as album_title, artist.id as artist_id, artist.name as artist_name 
   FROM album 
   LEFT JOIN album_artist ON album.id = album_artist.album_id 
   LEFT JOIN artist ON album_artist.artist_id = artist.id"]
({:id 4 
  :title "Magic Potion" 
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 5 
  :title "Thickfreakness" 
  :artists []} 
 {:id 6 
  :title "Let's Dance"
  :artists []})
</code>
</pre>

You may have noticed that some of the associations above were missing. Let's fix that.

<pre>
<code>
user> (! (conj-in ($1 :album {:title "Thickfreakness"} :with :artists)
                  [:artists]
                  ($1 :artist {:name "The Black Keys"})))
5

user> ($ :album :with :artists)
({:id 4 
  :title "Magic Potion" 
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 5 
  :title "Thickfreakness"
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 6 
  :title "Let's Dance" 
  :artists []}) 
</code>
</pre>

Let's do that again with debugging on.

<pre>
<code>
user> (binding [*debug* true] 
        (! (conj-in ($1 :album {:title "Let's Dance"} :with :artists)
                    [:artists]
                    ($1 :artist {:name "David Bowie"}))))
["SELECT album.id as album_id, album.title as album_title, artist.id as artist_id, artist.name as artist_name 
   FROM album 
   LEFT JOIN album_artist ON album.id = album_artist.album_id 
   LEFT JOIN artist ON album_artist.artist_id = artist.id 
   WHERE album.title = ?" "Let's Dance"]
["SELECT artist.id as artist_id, artist.name as artist_name FROM artist WHERE artist.name = ?" "David Bowie"] 
updating record in :album: {:title "Let's Dance"}
["SELECT * FROM album_artist WHERE album_artist.album_id = ?" 6]
inserting record into :album_artist: {:artist_id 4, :album_id 6}
["SELECT * FROM album_artist WHERE album_artist.artist_id = ? AND album_artist.album_id = ?" 4 6]
6

user> ($ :album :with :artists)
({:id 4 
  :title "Magic Potion" 
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 5 
  :title "Thickfreakness"
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 6 
  :title "Let's Dance" 
  :artists [{:id 4 :name "David Bowie"}]})
</code>
</pre>

Finally, we see an example of deleting something.

<pre>
<code>
user> ($ :album :with :artists)
({:id 4 
  :title "Magic Potion" 
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 5 
  :title "Thickfreakness"
  :artists [{:id 3 :name "The Black Keys"}]} 
 {:id 6 
  :title "Let's Dance" 
  :artists [{:id 4 :name "David Bowie"}]})

user> (first *1)
{:id 4 
  :title "Magic Potion" 
  :artists [{:id 3 :name "The Black Keys"}]}

user> (remove-in *1 [:artists] {:name "The Black Keys"})
{:id 4 :title "Magic Potion" :artists ()}

user> (binding [*debug* true] 
        (! *1))
updating record in :album: {:title "Magic Potion"}
["SELECT * FROM album_artist WHERE album_artist.album_id = ?" 10]
deleting record from :album_artist: {:artist_id 7, :album_id 10, :id 6}
10
</code>
</pre>

Before moving on, clean up the database so that the unit tests will be able to run against it.

<pre>
<code>
user> (delete-all-test-data)
</code>
</pre>

There is a lot more that carte can do. See the unit tests for more examples.

h2. TODO

<ol>
	<li>Refactor</li>
	<li>Add every kind of association to the example database and fill it with more data</li>
	<li>Update the docs to reflect the new data</li>
	<li>Demonstrate query with multiple associations</li>
	<li>Demonstrate query with where conditions on associate table</li>
    <li>Add support for ordering, limiting and paging results</li>    
	<li>If you use raw SQL to query data, the results should still have metadata so that you may use save-or-update on the resulting data structure. You will need to pass a data model in order for this to work.</li>
	<li>Add support for belongs-to and one-to-one associations</li>
	<li>Create more functions to help with manipulating data within nested data structures</li>
	<li>Clean up the code and tests</li>
	<li>Improve this documentation</li>
	<li>If you prefer to avoid a join and do two separate queries, provide a function that will merge the results into one data structure</li>
	<li>Before implementing backends for Derby and PostgreSQL, look into using ClojureQL to abstract SQL and do this for you<li>
	<li>Add support Derby and PostgreSQL</li>
	<li>Smarter Query Planning - currently there are some unnecessary queries being performed</li>
	<li>Think about putting the data model in the same map as the connection info in order to reduce the number of parameters that are passed around</li>
	<li>It would make the code much simpler to always qualify col names in queries</li>	
</ol>

h2. License

Copyright (C) 2010 Brenton Ashworth

Distributed under the Eclipse Public License, the same as Clojure uses. See the file COPYING.





